{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/polyfills.ts", "../library/src/utils/paths.ts", "../library/src/engine/signals.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/engine/engine.ts", "../library/src/plugins/actions/peek.ts", "../library/src/plugins/actions/setAll.ts", "../library/src/plugins/actions/toggleAll.ts", "../library/src/plugins/actions/fetch.ts", "../library/src/plugins/attributes/attr.ts", "../library/src/plugins/attributes/bind.ts", "../library/src/plugins/attributes/class.ts", "../library/src/plugins/attributes/computed.ts", "../library/src/plugins/attributes/effect.ts", "../library/src/plugins/attributes/indicator.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/attributes/init.ts", "../library/src/plugins/attributes/jsonSignals.ts", "../library/src/plugins/attributes/on.ts", "../library/src/utils/math.ts", "../library/src/plugins/attributes/onIntersect.ts", "../library/src/plugins/attributes/onInterval.ts", "../library/src/plugins/attributes/onSignalPatch.ts", "../library/src/plugins/attributes/ref.ts", "../library/src/plugins/attributes/show.ts", "../library/src/plugins/attributes/signals.ts", "../library/src/plugins/attributes/style.ts", "../library/src/plugins/attributes/text.ts", "../library/src/plugins/watchers/patchElements.ts", "../library/src/plugins/watchers/patchSignals.ts"],
  "sourcesContent": ["const lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\nexport const DATASTAR_FETCH_EVENT = 'datastar-fetch'\nexport const DATASTAR_SIGNAL_PATCH_EVENT = 'datastar-signal-patch'\n", "export const hasOwn: (obj: object, prop: PropertyKey) => boolean =\n  // @ts-expect-error\n  Object.hasOwn ?? Object.prototype.hasOwnProperty.call\n", "import type { Paths } from '@engine/types'\nimport { hasOwn } from '@utils/polyfills'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport const isEmpty = (obj: Record<string, any>): boolean => {\n  for (const prop in obj) {\n    if (hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const updateLeaves = (\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) => {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n", "import { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport type {\n  Computed,\n  Effect,\n  JSONPatch,\n  MergePatchArgs,\n  Paths,\n  Signal,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { isPojo, pathToObj } from '@utils/paths'\nimport { hasOwn } from '@utils/polyfills'\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  version_: number\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = unknown> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = unknown> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet prevSub: ReactiveNode | undefined\nlet activeSub: ReactiveNode | undefined\nlet version = 0\n\nexport const beginBatch = (): void => {\n  batchDepth++\n}\n\nexport const endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nexport const startPeeking = (sub?: ReactiveNode): void => {\n  prevSub = activeSub\n  activeSub = sub\n}\n\nexport const stopPeeking = (): void => {\n  activeSub = prevSub\n  prevSub = undefined\n}\n\nexport const signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nexport const computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-expect-error\n  c[computedSymbol] = 1\n  return c\n}\n\nexport const effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  startPeeking(e)\n  beginBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    stopPeeking()\n  }\n  return effectOper.bind(0, e)\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  startPeeking(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    stopPeeking()\n    endTracking(c)\n  }\n}\n\nconst updateSignal = <T>(s: AlienSignal<T>, value: T): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    startPeeking(e)\n    startTracking(e)\n    beginBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      stopPeeking()\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    if (s.value_ !== (s.value_ = value[0])) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  const nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n  if (nextDep && nextDep.dep_ === dep) {\n    nextDep.version_ = version\n    sub.depsTail_ = nextDep\n    return\n  }\n  const prevSub = dep.subsTail_\n  if (prevSub && prevSub.version_ === version && prevSub.sub_ === sub) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        version_: version,\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (\n      !(\n        flags &\n        (60 as\n          | ReactiveFlags.RecursedCheck\n          | ReactiveFlags.Recursed\n          | ReactiveFlags.Dirty\n          | ReactiveFlags.Pending)\n      )\n    ) {\n      sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n    ) {\n      flags = 0 satisfies ReactiveFlags.None\n    } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n      sub.flags_ =\n        (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n        (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n      isValidLink(link, sub)\n    ) {\n      sub.flags_ =\n        flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n      flags &= 1 satisfies ReactiveFlags.Mutable\n    } else {\n      flags = 0 satisfies ReactiveFlags.None\n    }\n\n    if (flags & (2 satisfies ReactiveFlags.Watching)) {\n      notify(sub as AlienEffect)\n    }\n\n    if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n      const subSubs = sub.subs_\n      if (subSubs) {\n        const nextSub = (link = subSubs).nextSub_\n        if (nextSub) {\n          stack = { value_: next, prev_: stack }\n          next = nextSub\n        }\n        continue\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  version++\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n  let dirty = false\n\n  top: while (true) {\n    const dep = link.dep_\n    const flags = dep.flags_\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (flags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (flags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty) {\n      const nextDep = link.nextDep_\n      if (nextDep) {\n        link = nextDep\n        continue\n      }\n    }\n\n    while (checkDepth--) {\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n        dirty = false\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const flags = sub.flags_\n    if (\n      (flags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = flags | (16 satisfies ReactiveFlags.Dirty)\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n  } while ((link = link.nextSub_!))\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  let link = sub.depsTail_\n  while (link) {\n    if (link === checkLink) {\n      return true\n    }\n    link = link.prevDep_\n  }\n  return false\n}\n\nexport const getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal<any>>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal<any>>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        // JSON.stringify calls `.toJSON()` directly instead of checking if it exists on the object\n        // so we have to check if `toJSON` is being called and prevent a signal from automatically\n        // being made so JSON.stringify can fallback to the default stringify\n        if (!(prop === 'toJSON' && !hasOwn(deepObj, prop))) {\n          // special case for when prop is an array function because every array function needs to\n          // be reactive to when the keys change\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          }\n          // if prop is a symbol just return the symbol because we don't want to make up that theres\n          // an iterator symbol on an object or not\n          if (typeof prop === 'symbol') {\n            return deepObj[prop]\n          }\n          // if obj doesnt have prop OR prop is null or undefined then create a signal and default\n          // to an empty string\n          if (!hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n            deepObj[prop] = signal('')\n            dispatch(prefix + prop, '')\n            keys(keys() + 1)\n          }\n          return deepObj[prop]()\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        // special case for when setting length so we can make a diff patch\n        if (isArr && prop === 'length') {\n          const diff = (deepObj[prop] as unknown as number) - newValue\n          deepObj[prop] = newValue\n          // manually make a diff patch for now, shouldnt have to do this when object diffing is\n          // implemented. see https://github.com/starfederation/datastar-dev/issues/274\n          if (diff > 0) {\n            const patch: Record<string, any> = {}\n            for (let i = newValue; i < deepObj[prop]; i++) {\n              patch[i] = null\n            }\n            dispatch(prefix.slice(0, -1), patch)\n            keys(keys() + 1)\n          }\n        } else if (hasOwn(deepObj, prop)) {\n          if (newValue == null) {\n            delete deepObj[prop]\n            // if newValue is a computed set the computed directly instead of wrapping in signal\n          } else if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n            // if prop changed after setting it then dispatch\n          } else {\n            const currentValue = deepObj[prop]()\n            const pathStr = `${path}.`\n            if (isPojo(currentValue) && isPojo(newValue)) {\n              for (const key in currentValue) {\n                if (!hasOwn(newValue, key)) {\n                  delete currentValue[key]\n                  dispatch(pathStr + key, null)\n                }\n              }\n              for (const key in newValue) {\n                const nextVal = newValue[key]\n                if (currentValue[key] !== nextVal) {\n                  currentValue[key] = nextVal\n                }\n              }\n            } else if (deepObj[prop](deep(newValue, pathStr))) {\n              dispatch(path, newValue)\n            }\n          }\n          // if newValue is null or undefined then noop\n        } else if (newValue != null) {\n          // if newValue is a computed set the computed directly instead of wrapping in signal\n          if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${path}.`))\n            dispatch(path, newValue)\n          }\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        delete deepObj[prop]\n        keys(keys() + 1)\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nexport const mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  beginBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nexport const mergePaths = (paths: Paths, options?: MergePatchArgs): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nconst toRegExp = (val: string | RegExp): RegExp =>\n  typeof val === 'string' ? RegExp(val.replace(/^\\/|\\/$/g, '')) : val\n\n/**\n * Filters the root store based on an include and exclude RegExp\n *\n * @returns The filtered object\n */\nexport const filtered = (\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> => {\n  const includeRe = toRegExp(include)\n  const excludeRe = toRegExp(exclude)\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (includeRe.test(path) && !excludeRe.test(path)) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nexport const root: Record<string, any> = deep({})\n", "import type { HTMLOrSVG } from '@engine/types'\n\nexport const isHTMLOrSVG = (el: Node): el is HTMLOrSVG =>\n  el instanceof HTMLElement ||\n  el instanceof SVGElement ||\n  el instanceof MathMLElement\n", "import type { Modifiers } from '@engine/types'\n\nexport const kebab = (str: string): string =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .replace(/[\\s_]+/g, '-') // Replace whitespace and underscores with hyphens\n    .toLowerCase()\n\nexport const camel = (str: string): string =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string): string => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string): string =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const title = (str: string): string =>\n  str.replace(/\\b\\w/g, (char) => char.toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = {\n  camel: (str) => str.replace(/-[a-z]/g, (x) => x[1].toUpperCase()),\n  snake: (str) => str.replace(/-/g, '_'),\n  pascal: (str) => str[0].toUpperCase() + caseFns.camel(str.slice(1)),\n}\n\nexport const modifyCasing = (\n  str: string,\n  mods: Modifiers,\n  defaultCase = 'camel',\n): string => {\n  for (const c of mods.get('case') || [defaultCase]) {\n    str = caseFns[c]?.(str) || str\n  }\n  return str\n}\n\nexport const aliasify = (name: string) =>\n  ALIAS ? `data-${ALIAS}-${name}` : `data-${name}`\n", "import { DATASTAR_FETCH_EVENT, DSP, DSS } from '@engine/consts'\nimport { root } from '@engine/signals'\nimport type {\n  ActionContext,\n  ActionPlugin,\n  AttributeContext,\n  AttributePlugin,\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  Modifiers,\n  Requirement,\n  WatcherPlugin,\n} from '@engine/types'\nimport { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify, snake } from '@utils/text'\n\nconst url = 'https://data-star.dev/errors'\n\nconst error = (\n  ctx: Record<string, any>,\n  reason: string,\n  metadata: Record<string, any> = {},\n) => {\n  Object.assign(metadata, ctx)\n  const e = new Error()\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nconst actionPlugins: Map<string, ActionPlugin> = new Map()\nconst attributePlugins: Map<string, AttributePlugin> = new Map()\nconst watcherPlugins: Map<string, WatcherPlugin> = new Map()\n\nexport const actions: Record<\n  string,\n  (ctx: ActionContext, ...args: any[]) => any\n> = new Proxy(\n  {},\n  {\n    get: (_, prop: string) => actionPlugins.get(prop)?.apply,\n    has: (_, prop: string) => actionPlugins.has(prop),\n    ownKeys: () => Reflect.ownKeys(actionPlugins),\n    set: () => false,\n    deleteProperty: () => false,\n  },\n)\n\n// Map of cleanups keyed by element, attribute name, and cleanup name\nconst removals = new Map<HTMLOrSVG, Map<string, Map<string, () => void>>>()\n\nconst queuedAttributes: AttributePlugin[] = []\nconst queuedAttributeNames = new Set<string>()\nconst observedRoots = new WeakSet<Node>()\nexport const attribute = <R extends Requirement, B extends boolean>(\n  plugin: AttributePlugin<R, B>,\n): void => {\n  queuedAttributes.push(plugin as unknown as AttributePlugin)\n\n  if (queuedAttributes.length === 1) {\n    setTimeout(() => {\n      for (const attribute of queuedAttributes) {\n        queuedAttributeNames.add(attribute.name)\n        attributePlugins.set(attribute.name, attribute)\n      }\n      queuedAttributes.length = 0\n      apply()\n      queuedAttributeNames.clear()\n    })\n  }\n}\n\nexport const action = <T>(plugin: ActionPlugin<T>): void => {\n  actionPlugins.set(plugin.name, plugin)\n}\n\ndocument.addEventListener(DATASTAR_FETCH_EVENT, ((\n  evt: CustomEvent<DatastarFetchEvent>,\n) => {\n  const plugin = watcherPlugins.get(evt.detail.type)\n  if (plugin) {\n    plugin.apply(\n      {\n        error: error.bind(0, {\n          plugin: { type: 'watcher', name: plugin.name },\n          element: {\n            id: (evt.target as Element).id,\n            tag: (evt.target as Element).tagName,\n          },\n        }),\n      },\n      evt.detail.argsRaw,\n    )\n  }\n}) as EventListener)\n\nexport const watcher = (plugin: WatcherPlugin): void => {\n  watcherPlugins.set(plugin.name, plugin)\n}\n\nconst cleanupEls = (els: Iterable<HTMLOrSVG>): void => {\n  for (const el of els) {\n    const elCleanups = removals.get(el)\n    if (elCleanups && removals.delete(el)) {\n      for (const attrCleanups of elCleanups.values()) {\n        for (const cleanup of attrCleanups.values()) {\n          cleanup()\n        }\n      }\n    }\n  }\n}\n\nconst aliasedIgnore = aliasify('ignore')\nconst aliasedIgnoreAttr = `[${aliasedIgnore}]`\nconst shouldIgnore = (el: HTMLOrSVG) =>\n  el.hasAttribute(`${aliasedIgnore}__self`) || !!el.closest(aliasedIgnoreAttr)\n\nconst applyEls = (els: Iterable<HTMLOrSVG>, onlyNew?: boolean): void => {\n  for (const el of els) {\n    if (!shouldIgnore(el)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(\n          el,\n          key.replace(/[A-Z]/g, '-$&').toLowerCase(),\n          el.dataset[key]!,\n          onlyNew,\n        )\n      }\n    }\n  }\n}\n\nconst observe = (mutations: MutationRecord[]) => {\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (\n      type === 'attributes' &&\n      attributeName!.startsWith('data-') &&\n      isHTMLOrSVG(target) &&\n      !shouldIgnore(target)\n    ) {\n      // skip over 'data-'\n      const key = attributeName!.slice(5)\n      const value = target.getAttribute(attributeName!)\n      if (value === null) {\n        const elCleanups = removals.get(target)\n        if (elCleanups) {\n          const attrCleanups = elCleanups.get(key)\n          if (attrCleanups) {\n            for (const cleanup of attrCleanups.values()) {\n              cleanup()\n            }\n            elCleanups.delete(key)\n          }\n        }\n      } else {\n        applyAttributePlugin(target, key, value)\n      }\n    }\n  }\n}\n\n// TODO: mutation observer per root so applying to web component doesnt overwrite main observer\nconst mutationObserver = new MutationObserver(observe)\n\nexport const parseAttributeKey = (\n  rawKey: string,\n): {\n  pluginName: string\n  key: string | undefined\n  mods: Modifiers\n} => {\n  const [namePart, ...rawModifiers] = rawKey.split('__')\n  const [pluginName, key] = namePart.split(/:(.+)/)\n  const mods: Modifiers = new Map()\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    mods.set(label, new Set(mod))\n  }\n\n  return { pluginName, key, mods }\n}\n\nexport const isDocumentObserverActive = () =>\n  observedRoots.has(document.documentElement)\n\nexport const apply = (\n  root: HTMLOrSVG | ShadowRoot = document.documentElement,\n  observeRoot = true,\n): void => {\n  if (isHTMLOrSVG(root)) {\n    applyEls([root], true)\n  }\n  applyEls(root.querySelectorAll<HTMLOrSVG>('*'), true)\n\n  if (observeRoot) {\n    mutationObserver.observe(root, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n    })\n    observedRoots.add(root)\n  }\n}\n\nconst applyAttributePlugin = (\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n  onlyNew?: boolean,\n): void => {\n  if (!ALIAS || attrKey.startsWith(`${ALIAS}-`)) {\n    const rawKey = ALIAS ? attrKey.slice(ALIAS.length + 1) : attrKey\n    const { pluginName, key, mods } = parseAttributeKey(rawKey)\n    const plugin = attributePlugins.get(pluginName)\n    if ((!onlyNew || queuedAttributeNames.has(pluginName)) && plugin) {\n      const ctx = {\n        el,\n        rawKey,\n        mods,\n        error: error.bind(0, {\n          plugin: { type: 'attribute', name: plugin.name },\n          element: { id: el.id, tag: el.tagName },\n          expression: { rawKey, key, value },\n        }),\n        key,\n        value,\n        loadedPluginNames: {\n          actions: new Set(actionPlugins.keys()),\n          attributes: new Set(attributePlugins.keys()),\n        },\n        rx: undefined,\n      } as AttributeContext\n\n      const keyReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.key)) ||\n        'allowed'\n      const valueReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.value)) ||\n        'allowed'\n\n      const keyProvided = key !== undefined && key !== null && key !== ''\n      const valueProvided =\n        value !== undefined && value !== null && value !== ''\n\n      if (keyProvided) {\n        if (keyReq === 'denied') {\n          throw ctx.error('KeyNotAllowed')\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.error('KeyRequired')\n      }\n\n      if (valueProvided) {\n        if (valueReq === 'denied') {\n          throw ctx.error('ValueNotAllowed')\n        }\n      } else if (valueReq === 'must') {\n        throw ctx.error('ValueRequired')\n      }\n\n      if (keyReq === 'exclusive' || valueReq === 'exclusive') {\n        if (keyProvided && valueProvided) {\n          throw ctx.error('KeyAndValueProvided')\n        }\n        if (!keyProvided && !valueProvided) {\n          throw ctx.error('KeyOrValueRequired')\n        }\n      }\n\n      const cleanups = new Map<string, () => void>()\n      if (valueProvided) {\n        let cachedRx: GenRxFn\n        ctx.rx = (...args: any[]) => {\n          if (!cachedRx) {\n            cachedRx = genRx(value, {\n              returnsValue: plugin.returnsValue,\n              argNames: plugin.argNames,\n              cleanups,\n            })\n          }\n          return cachedRx(el, ...args)\n        }\n      }\n\n      const cleanup = plugin.apply(ctx)\n      if (cleanup) {\n        cleanups.set('attribute', cleanup)\n      }\n\n      let elCleanups = removals.get(el)\n      if (elCleanups) {\n        const attrCleanups = elCleanups.get(rawKey)\n        if (attrCleanups) {\n          for (const oldCleanup of attrCleanups.values()) {\n            oldCleanup()\n          }\n        }\n      } else {\n        elCleanups = new Map()\n        removals.set(el, elCleanups)\n      }\n      elCleanups.set(rawKey, cleanups)\n    }\n  }\n}\n\ntype GenRxOptions = {\n  returnsValue?: boolean\n  argNames?: string[]\n  cleanups?: Map<string, () => void>\n}\n\ntype GenRxFn = <T>(el: HTMLOrSVG, ...args: any[]) => T\n\nconst genRx = (\n  value: string,\n  {\n    returnsValue = false,\n    argNames = [],\n    cleanups = new Map(),\n  }: GenRxOptions = {},\n): GenRxFn => {\n  let expr = ''\n  if (returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = value.trim()\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `__escaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          -> $['count']\n  //   $count--        -> $['count']--\n  //   $foo.bar        -> $['foo']['bar']\n  //   $foo-bar        -> $['foo-bar']\n  //   $foo.bar-baz    -> $['foo']['bar-baz']\n  //   $foo-$bar       -> $['foo']-$['bar']\n  //   $arr[$index]    -> $['arr'][$['index']]\n  //   $['foo']        -> $['foo']\n  //   $foo[obj.bar]   -> $['foo'][obj.bar]\n  //   $foo['bar.baz'] -> $['foo']['bar.baz']\n  //   $123            -> $['123']\n  //   $foo.0.name     -> $['foo']['0']['name']\n\n  expr = expr\n    // $['x'] -> $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x -> $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) =>\n      signalName\n        .split('.')\n        .reduce((acc: string, part: string) => `${acc}['${part}']`, '$'),\n    )\n\n  expr = expr.replaceAll(/@([A-Za-z_$][\\w$]*)\\(/g, '__action(\"$1\",evt,')\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  try {\n    const fn = Function('el', '$', '__action', 'evt', ...argNames, expr)\n    return (el: HTMLOrSVG, ...args: any[]) => {\n      const action = (name: string, evt: Event | undefined, ...args: any[]) => {\n        const err = error.bind(0, {\n          plugin: { type: 'action', name },\n          element: { id: el.id, tag: el.tagName },\n          expression: {\n            fnContent: expr,\n            value,\n          },\n        })\n        const fn = actions[name]\n        if (fn) {\n          return fn(\n            {\n              el,\n              evt,\n              error: err,\n              cleanups,\n            },\n            ...args,\n          )\n        }\n        throw err('UndefinedAction')\n      }\n      try {\n        return fn(el, root, action, undefined, ...args)\n      } catch (e: any) {\n        console.error(e)\n        throw error(\n          {\n            element: { id: el.id, tag: el.tagName },\n            expression: {\n              fnContent: expr,\n              value,\n            },\n            error: e.message,\n          },\n          'ExecuteExpression',\n        )\n      }\n    }\n  } catch (e: any) {\n    console.error(e)\n    throw error(\n      {\n        expression: {\n          fnContent: expr,\n          value,\n        },\n        error: e.message,\n      },\n      'GenerateExpression',\n    )\n  }\n}\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { startPeeking, stopPeeking } from '@engine/signals'\n\naction({\n  name: 'peek',\n  apply(_, fn: () => any) {\n    startPeeking()\n    try {\n      return fn()\n    } finally {\n      stopPeeking()\n    }\n  },\n})\n", "// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'setAll',\n  apply(_, value: any, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, () => value)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'toggleAll',\n  apply(_, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, (oldValue: any) => !oldValue)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { filtered, startPeeking, stopPeeking } from '@engine/signals'\nimport type {\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { kebab } from '@utils/text'\n\nconst createHttpMethod = (\n  name: string,\n  method: string,\n  openWhenHiddenDefault: boolean = true,\n): void =>\n  action({\n    name,\n    apply: async (\n      { el, evt, error, cleanups },\n      url: string,\n      {\n        selector,\n        headers: userHeaders,\n        contentType = 'json',\n        filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n        openWhenHidden = openWhenHiddenDefault,\n        payload,\n        requestCancellation = 'auto',\n        retry = 'auto',\n        retryInterval = 1_000,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n      }: FetchArgs = {},\n    ) => {\n      const controller =\n        requestCancellation instanceof AbortController\n          ? requestCancellation\n          : new AbortController()\n      if (requestCancellation === 'auto') {\n        cleanups.get(`@${name}`)?.()\n        cleanups.set(`@${name}`, async () => {\n          controller.abort()\n          // wait one tick for FINISHED to fire\n          await Promise.resolve()\n        })\n      }\n\n      let cleanupFn = null\n\n      try {\n        if (!url?.length) {\n          throw error('FetchNoUrlProvided', { action })\n        }\n\n        const initialHeaders: Record<string, any> = {\n          Accept: 'text/event-stream, text/html, application/json',\n          'Datastar-Request': true,\n        }\n        if (contentType === 'json') {\n          initialHeaders['Content-Type'] = 'application/json'\n        }\n        const headers = Object.assign({}, initialHeaders, userHeaders)\n\n        // We ignore the content-type header if using form data\n        // if missing the boundary will be set automatically\n\n        const req: FetchEventSourceInit = {\n          method,\n          headers,\n          openWhenHidden,\n          retry,\n          retryInterval,\n          retryScaler,\n          retryMaxWaitMs,\n          retryMaxCount,\n          signal: controller.signal,\n          onopen: async (response: Response) => {\n            if (response.status >= 400)\n              dispatchFetch(ERROR, el, { status: response.status.toString() })\n          },\n          onmessage: (evt) => {\n            if (!evt.event.startsWith('datastar')) return\n            const type = evt.event\n            const argsRawLines: Record<string, string[]> = {}\n\n            for (const line of evt.data.split('\\n')) {\n              const i = line.indexOf(' ')\n              const k = line.slice(0, i)\n              const v = line.slice(i + 1)\n              ;(argsRawLines[k] ||= []).push(v)\n            }\n\n            const argsRaw = Object.fromEntries(\n              Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n            )\n\n            dispatchFetch(type, el, argsRaw)\n          },\n          onerror: (error) => {\n            if (isWrongContent(error)) {\n              // don't retry if the content-type is wrong\n              throw error('FetchExpectedTextEventStream', { url })\n            }\n            // do nothing and it will retry\n            if (error) {\n              console.error(error.message)\n              dispatchFetch(RETRYING, el, { message: error.message })\n            }\n          },\n        }\n\n        const urlInstance = new URL(url, document.baseURI)\n        const queryParams = new URLSearchParams(urlInstance.search)\n\n        if (contentType === 'json') {\n          startPeeking()\n          payload =\n            payload !== undefined ? payload : filtered({ include, exclude })\n          stopPeeking()\n          const body = JSON.stringify(payload)\n          if (method === 'GET') {\n            queryParams.set('datastar', body)\n          } else {\n            req.body = body\n          }\n        } else if (contentType === 'form') {\n          const formEl = (\n            selector ? document.querySelector(selector) : el.closest('form')\n          ) as HTMLFormElement\n          if (!formEl) {\n            throw error('FetchFormNotFound', { action, selector })\n          }\n\n          // Validate the form\n          if (!formEl.noValidate && !formEl.checkValidity()) {\n            formEl.reportValidity()\n            return\n          }\n\n          // Collect the form data\n          const formData = new FormData(formEl)\n          let submitter = el as HTMLElement | null\n\n          if (el === formEl && evt instanceof SubmitEvent) {\n            // Get the submitter from the event\n            submitter = evt.submitter\n          } else {\n            // Prevent the form being submitted\n            const preventDefault = (evt: Event) => evt.preventDefault()\n            formEl.addEventListener('submit', preventDefault)\n            cleanupFn = () => {\n              formEl.removeEventListener('submit', preventDefault)\n            }\n          }\n\n          // Append the value of the form submitter if it is a button with a name\n          if (submitter instanceof HTMLButtonElement) {\n            const name = submitter.getAttribute('name')\n            if (name) formData.append(name, submitter.value)\n          }\n\n          const multipart =\n            formEl.getAttribute('enctype') === 'multipart/form-data'\n          // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n          if (!multipart) {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded'\n          }\n\n          const formParams = new URLSearchParams(formData as any)\n          if (method === 'GET') {\n            for (const [key, value] of formParams) {\n              queryParams.append(key, value)\n            }\n          } else if (multipart) {\n            req.body = formData\n          } else {\n            req.body = formParams\n          }\n        } else {\n          throw error('FetchInvalidContentType', { action, contentType })\n        }\n\n        dispatchFetch(STARTED, el, {})\n        urlInstance.search = queryParams.toString()\n\n        try {\n          await fetchEventSource(urlInstance.toString(), el, req)\n        } catch (e: any) {\n          if (!isWrongContent(e)) {\n            throw error('FetchFailed', { method, url, error: e.message })\n          }\n          // exit gracefully and do nothing if the content-type is wrong\n          // this can happen if the client is sending a request\n          // where no response is expected, and they haven\u2019t\n          // set the content-type to text/event-stream\n        }\n      } finally {\n        dispatchFetch(FINISHED, el, {})\n        cleanupFn?.()\n        cleanups.delete(`@${name}`)\n      }\n    },\n  })\n\ncreateHttpMethod('get', 'GET', false)\ncreateHttpMethod('patch', 'PATCH')\ncreateHttpMethod('post', 'POST')\ncreateHttpMethod('put', 'PUT')\ncreateHttpMethod('delete', 'DELETE')\n\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nconst dispatchFetch = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      namespace?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  selector?: string\n  headers?: Record<string, string>\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  openWhenHidden?: boolean\n  payload?: any\n  requestCancellation?: 'auto' | 'disabled' | AbortController\n  responseOverrides?: ResponseOverrides\n  retry?: 'auto' | 'error' | 'always' | 'never'\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nconst getBytes = async (\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> => {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nconst getLines = (onLine: (line: Uint8Array, fieldLength: number) => void) => {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return (arr: Uint8Array) => {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-expect-error:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nconst getMessages = (\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n): ((line: Uint8Array, fieldLength: number) => void) => {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return (line, fieldLength) => {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ntype FetchEventSourceInit = RequestInit & {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retry?: 'auto' | 'error' | 'always' | 'never'\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  responseOverrides?: ResponseOverrides\n}\n\nconst fetchEventSource = (\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retry = 'auto',\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    responseOverrides,\n    ...rest\n  }: FetchEventSourceInit,\n): Promise<void> => {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    const onVisibilityChange = () => {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer: ReturnType<typeof setTimeout> | undefined\n    const dispose = () => {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    const create = async () => {\n      curRequestController = new AbortController()\n      const curRequestSignal = curRequestController.signal\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestSignal,\n        })\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          responseOverrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (responseOverrides) {\n              const o = (responseOverrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchFetch(dispatchType, el, argsRaw)\n          dispose()\n          resolve()\n        }\n\n        const status = response.status\n        const isNoContentStatus = status === 204\n        const isRedirectStatus = status >= 300 && status < 400\n        const isErrorStatus = status >= 400 && status < 600\n\n        if (status !== 200) {\n          onclose?.()\n          if (\n            retry !== 'never' &&\n            !isNoContentStatus &&\n            !isRedirectStatus &&\n            (retry === 'always' || (retry === 'error' && isErrorStatus))\n          ) {\n            clearTimeout(retryTimer)\n            retryTimer = setTimeout(create, retryInterval)\n            return\n          }\n          dispose()\n          resolve()\n          return\n        }\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            'datastar-patch-elements',\n            response,\n            'elements',\n            responseOverrides,\n            'selector',\n            'mode',\n            'namespace',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            'datastar-patch-signals',\n            response,\n            'signals',\n            responseOverrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n\n        if (retry === 'always' && !isRedirectStatus) {\n          clearTimeout(retryTimer)\n          retryTimer = setTimeout(create, retryInterval)\n          return\n        }\n\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestSignal.aborted) {\n          // if we haven\u2019t aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            clearTimeout(retryTimer)\n            retryTimer = setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchFetch(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'attr',\n  requirement: { value: 'must' },\n  returnsValue: true,\n  apply({ el, key, rx }) {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx() as string\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx() as Record<string, any>\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn\u2019t already exist) and sets up two-way data binding between it and an element\u2019s value.\n\nimport { attribute } from '@engine'\nimport { effect, getPath, mergePaths } from '@engine/signals'\nimport type { Paths } from '@engine/types'\nimport { aliasify, modifyCasing } from '@utils/text'\n\ntype SignalFile = {\n  name: string\n  contents: string\n  mime: string\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nconst aliasedBind = aliasify('bind')\n\nattribute({\n  name: 'bind',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value, error }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const signalFiles: SignalFile[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw error('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw error('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      signalFiles.push({\n                        name: f.name,\n                        contents: match.groups.contents,\n                        mime: match.groups.mime,\n                      })\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePaths([[signalName, signalFiles]])\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const signalNameKebab = key ? key : value!\n      const inputs = document.querySelectorAll(\n        `[${aliasedBind}\\\\:${CSS.escape(signalNameKebab)}],[${aliasedBind}=\"${CSS.escape(signalNameKebab)}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const paths: Paths = []\n      let i = 0\n      for (const input of inputs) {\n        paths.push([`${path}.${i}`, get(input, 'none')])\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePaths(paths, { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePaths([[path, get(el, type)]], {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePaths([[path, value]])\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n})\n", "// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'class',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, mods, rx }) {\n    key &&= modifyCasing(key, mods, 'kebab')\n\n    let classes: Record<string, boolean>\n    const callback = () => {\n      observer.disconnect()\n\n      classes = key\n        ? { [key]: rx() as boolean }\n        : (rx() as Record<string, boolean>)\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n})\n", "// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport { attribute } from '@engine'\nimport { computed, mergePaths, mergePatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { updateLeaves } from '@utils/paths'\n\nattribute({\n  name: 'computed',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, mods, rx, error }) {\n    if (key) {\n      mergePaths([[modifyCasing(key, mods), computed(rx)]])\n    } else {\n      const patch = Object.assign({}, rx() as Record<string, () => any>)\n      updateLeaves(patch, (old) => {\n        if (typeof old === 'function') {\n          return computed(old)\n        } else {\n          throw error('ComputedExpectedFunction')\n        }\n      })\n      mergePatch(patch)\n    }\n  },\n})\n", "// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'effect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply: ({ rx }) => effect(rx),\n})\n", "// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { mergePaths } from '@engine/signals'\nimport type { DatastarFetchEvent } from '@engine/types'\nimport { FINISHED, STARTED } from '@plugins/actions/fetch'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'indicator',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    mergePaths([[signalName, false]])\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePaths([[signalName, true]])\n          break\n        case FINISHED:\n          mergePaths([[signalName, false]])\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePaths([[signalName, false]])\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n})\n", "export const tagToMs = (args: Set<string>) => {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport const tagHas = (\n  tags: Set<string>,\n  tag: string,\n  defaultValue = false,\n) => {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport const tagFirst = (tags?: Set<string>, defaultValue = ''): string => {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '@engine/types'\nimport { tagHas, tagToMs } from '@utils/tags'\n\nexport const delay = (\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler => {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport const throttle = (\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n  debounce = false,\n): EventCallbackHandler => {\n  let lastArgs: Parameters<EventCallbackHandler> | null = null\n  let timer = 0\n\n  return (...args: any[]) => {\n    if (leading && !timer) {\n      callback(...args)\n      lastArgs = null\n    } else {\n      lastArgs = args\n    }\n    if (!timer || debounce) {\n      if (timer) {\n        clearTimeout(timer)\n      }\n      timer = setTimeout(() => {\n        if (trailing && lastArgs !== null) {\n          callback(...lastArgs)\n        }\n        lastArgs = null\n        timer = 0\n      }, wait)\n    }\n  }\n}\n\nexport const modifyTiming = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrailing', false)\n    callback = throttle(callback, wait, leading, trailing, true)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trailing', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '@engine/types'\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport const modifyViewTransition = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagToMs } from '@utils/tags'\nimport { delay } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'init',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ rx, mods }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n      if (wait > 0) {\n        callback = delay(callback, wait)\n      }\n    }\n    callback()\n  },\n})\n", "// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport { attribute } from '@engine'\nimport { effect, filtered } from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { jsStrToObject } from '@utils/text'\n\nattribute({\n  name: 'json-signals',\n  requirement: {\n    key: 'denied',\n  },\n  apply({ el, value, mods }) {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport { attribute } from '@engine'\nimport {\n  DATASTAR_FETCH_EVENT,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '@engine/consts'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on',\n  requirement: 'must',\n  argNames: ['evt'],\n  apply({ el, key, mods, rx }) {\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n      }\n      beginBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    const eventName = modifyCasing(key, mods, 'kebab')\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n})\n", "export const clamp = (value: number, min: number, max: number): number => {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport const lerp = (\n  min: number,\n  max: number,\n  t: number,\n  clamped = true,\n): number => {\n  const v = min + (max - min) * t\n  return clamped ? clamp(v, min, max) : v\n}\n\nexport const inverseLerp = (\n  min: number,\n  max: number,\n  value: number,\n  clamped = true,\n): number => {\n  if (value < min) return 0\n  if (value > max) return 1\n  const v = (value - min) / (max - min)\n  return clamped ? clamp(v, min, max) : v\n}\n\nexport const fit = (\n  value: number,\n  inMin: number,\n  inMax: number,\n  outMin: number,\n  outMax: number,\n  clamped = true,\n  rounded = false,\n): number => {\n  const t = inverseLerp(inMin, inMax, value, clamped)\n  const fitted = lerp(outMin, outMax, t, clamped)\n  return rounded ? Math.round(fitted) : fitted\n}\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport type { HTMLOrSVG } from '@engine/types'\nimport { clamp } from '@utils/math'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nattribute({\n  name: 'on-intersect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ el, mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    } else if (mods.get('threshold')) {\n      options.threshold = clamp(Number(mods.get('threshold')), 0, 100) / 100\n    }\n    const exit = mods.has('exit')\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting !== exit) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n})\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagHas, tagToMs } from '@utils/tags'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on-interval',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n})\n", "// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport { beginBatch, endBatch, filtered } from '@engine/signals'\nimport type { JSONPatch, SignalFilterOptions } from '@engine/types'\nimport { isEmpty } from '@utils/paths'\nimport { aliasify, jsStrToObject } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\n\nattribute({\n  name: 'on-signal-patch',\n  requirement: {\n    value: 'must',\n  },\n  argNames: ['patch'],\n  returnsValue: true,\n  apply({ el, key, mods, rx, error }) {\n    if (!!key && key !== 'filter') {\n      throw error('KeyNotAllowed')\n    }\n\n    const filterAttr = aliasify(`${this.name}-filter`)\n    const filtersRaw = el.getAttribute(filterAttr)\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    let running = false\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        if (running) return\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          running = true\n          beginBatch()\n          try {\n            rx(watched)\n          } finally {\n            endBatch()\n            running = false\n          }\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n})\n", "// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport { attribute } from '@engine'\nimport { mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'ref',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n    mergePaths([[signalName, el]])\n  },\n})\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nattribute({\n  name: 'show',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport { attribute } from '@engine'\nimport { mergePatch, mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'signals',\n  returnsValue: true,\n  apply({ key, mods, rx }) {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePaths([[key, rx?.()]], { ifMissing })\n    } else {\n      const patch = Object.assign({}, rx?.() as Record<string, any>)\n      mergePatch(patch, { ifMissing })\n    }\n  },\n})\n", "// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { kebab } from '@utils/text'\n\nattribute({\n  name: 'style',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, rx }) {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx() as Record<string, any>\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n})\n", "// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'text',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport { watcher } from '@engine'\nimport type { WatcherContext } from '@engine/types'\nimport { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify } from '@utils/text'\nimport { supportsViewTransitions } from '@utils/view-transitions'\n\nconst isValidType = <T extends readonly string[]>(\n  arr: T,\n  value: string,\n): value is T[number] => (arr as readonly string[]).includes(value)\n\nconst PATCH_MODES = [\n  'remove',\n  'outer',\n  'inner',\n  'replace',\n  'prepend',\n  'append',\n  'before',\n  'after',\n] as const\ntype PatchElementsMode = (typeof PATCH_MODES)[number]\n\nconst NAMESPACES = ['html', 'svg', 'mathml'] as const\ntype Namespace = (typeof NAMESPACES)[number]\n\ntype PatchElementsArgs = {\n  selector: string\n  mode: PatchElementsMode\n  namespace: Namespace\n  useViewTransition: boolean\n  elements: string\n}\n\nwatcher({\n  name: 'datastar-patch-elements',\n  apply(\n    ctx,\n    {\n      selector = '',\n      mode = 'outer',\n      namespace = 'html',\n      useViewTransition = '',\n      elements = '',\n    },\n  ) {\n    if (!isValidType(PATCH_MODES, mode)) {\n      throw ctx.error('PatchElementsInvalidMode', { mode })\n    }\n\n    if (!selector && mode !== 'outer' && mode !== 'replace') {\n      throw ctx.error('PatchElementsExpectedSelector')\n    }\n\n    if (!isValidType(NAMESPACES, namespace)) {\n      throw ctx.error('PatchElementsInvalidNamespace', { namespace })\n    }\n\n    const args2: PatchElementsArgs = {\n      selector,\n      mode,\n      namespace,\n      useViewTransition: useViewTransition.trim() === 'true',\n      elements,\n    }\n\n    if (supportsViewTransitions && useViewTransition) {\n      document.startViewTransition(() => onPatchElements(ctx, args2))\n    } else {\n      onPatchElements(ctx, args2)\n    }\n  },\n})\n\nconst onPatchElements = (\n  { error }: WatcherContext,\n  { selector, mode, namespace, elements }: PatchElementsArgs,\n) => {\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const wrapperTag =\n    namespace === 'svg' ? 'svg' : namespace === 'mathml' ? 'math' : ''\n  const wrappedEls = wrapperTag\n    ? `<${wrapperTag}>${elements}</${wrapperTag}>`\n    : elements\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${wrappedEls}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else if (wrapperTag) {\n    const wrapperEl = newDocument\n      .querySelector('template')!\n      .content.querySelector(wrapperTag)!\n    for (const child of wrapperEl.childNodes) {\n      newContent.appendChild(child)\n    }\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (!selector && (mode === 'outer' || mode === 'replace')) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.warn(error('PatchElementsNoTargetsFound'), {\n            element: { id: child.id },\n          })\n          continue\n        }\n      }\n\n      applyToTargets(mode as PatchElementsMode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.warn(error('PatchElementsNoTargetsFound'), { selector })\n      return\n    }\n\n    applyToTargets(mode as PatchElementsMode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nconst execute = (target: Element): void => {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nconst applyPatchMode = (\n  targets: Iterable<Element>,\n  element: DocumentFragment | Element,\n  action: string,\n) => {\n  for (const target of targets) {\n    const cloned = element.cloneNode(true) as Element\n    execute(cloned)\n    // @ts-expect-error\n    target[action](cloned)\n  }\n}\n\nconst applyToTargets = (\n  mode: PatchElementsMode,\n  element: DocumentFragment | Element,\n  targets: Iterable<Element>,\n) => {\n  switch (mode) {\n    case 'remove':\n      for (const target of targets) {\n        target.remove()\n      }\n      break\n    case 'outer':\n    case 'inner':\n      for (const target of targets) {\n        morph(target, element.cloneNode(true) as Element, mode)\n        execute(target)\n      }\n      break\n    case 'replace':\n      applyPatchMode(targets, element, 'replaceWith')\n      break\n    case 'prepend':\n    case 'append':\n    case 'before':\n    case 'after':\n      applyPatchMode(targets, element, mode)\n  }\n}\n\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst oldIdTagNameMap = new Map<string, string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nconst aliasedIgnoreMorph = aliasify('ignore-morph')\nconst aliasedIgnoreMorphAttr = `[${aliasedIgnoreMorph}]`\nconst morph = (\n  oldElt: Element | ShadowRoot,\n  newContent: DocumentFragment | Element,\n  mode: 'outer' | 'inner' = 'outer',\n): void => {\n  if (\n    (isHTMLOrSVG(oldElt) &&\n      isHTMLOrSVG(newContent) &&\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newContent.hasAttribute(aliasedIgnoreMorph)) ||\n    oldElt.parentElement?.closest(aliasedIgnoreMorphAttr)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt instanceof Element && oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  oldIdTagNameMap.clear()\n  duplicateIds.clear()\n  ctxIdMap.clear()\n\n  const parent = mode === 'outer' ? oldElt.parentElement! : oldElt\n  populateIdMapWithTree(parent, oldIdElements)\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    parent,\n    normalizedElt,\n    mode === 'outer' ? oldElt : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nconst morphChildren = (\n  oldParent: Element | ShadowRoot, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void => {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(newChild.id)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n      const movedChild = document.getElementById(newChild.id) as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(newChild.id)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const namespaceURI = (newChild as Element).namespaceURI\n      const tagName = (newChild as Element).tagName\n      const newEmptyChild =\n        namespaceURI && namespaceURI !== 'http://www.w3.org/1999/xhtml'\n          ? document.createElementNS(namespaceURI, tagName)\n          : document.createElement(tagName)\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nconst findBestMatch = (\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null => {\n  let bestMatch: Node | null | undefined = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven\u2019t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\n// ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\nconst isSoftMatch = (oldNode: Node, newNode: Node): boolean =>\n  oldNode.nodeType === newNode.nodeType &&\n  (oldNode as Element).tagName === (newNode as Element).tagName &&\n  // If oldElt has an `id` with possible state and it doesn\u2019t match newElt.id then avoid morphing.\n  // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n  // its not persistent, and new nodes can't have any hidden state.\n  (!(oldNode as Element).id ||\n    (oldNode as Element).id === (newNode as Element).id)\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nconst removeNode = (node: Node): void => {\n  // are we going to id set match this later?\n  ctxIdMap.has(node)\n    ? // skip callbacks and move to pantry\n      moveBefore(ctxPantry, node, null)\n    : // remove for realsies\n      node.parentNode?.removeChild(node)\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-expect-error\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nconst aliasedPreserveAttr = aliasify('preserve-attr')\n\n// syncs the oldNode to the newNode, copying over all attributes and\n// inner element state from the newNode to the oldNode\nconst morphNode = (\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node => {\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const oldElt = oldNode as Element\n    const newElt = newNode as Element\n    const shouldScopeChildren = oldElt.hasAttribute('data-scope-children')\n    if (\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newElt.hasAttribute(aliasedIgnoreMorph)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldElt instanceof HTMLInputElement &&\n      newElt instanceof HTMLInputElement &&\n      newElt.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newElt.getAttribute('value') !== oldElt.getAttribute('value')) {\n        oldElt.value = newElt.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldElt instanceof HTMLTextAreaElement &&\n      newElt instanceof HTMLTextAreaElement\n    ) {\n      if (newElt.value !== oldElt.value) {\n        oldElt.value = newElt.value\n      }\n      if (oldElt.firstChild && oldElt.firstChild.nodeValue !== newElt.value) {\n        oldElt.firstChild.nodeValue = newElt.value\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasedPreserveAttr) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of newElt.attributes) {\n      if (\n        oldElt.getAttribute(name) !== value &&\n        !preserveAttrs.includes(name)\n      ) {\n        oldElt.setAttribute(name, value)\n      }\n    }\n\n    for (let i = oldElt.attributes.length - 1; i >= 0; i--) {\n      const { name } = oldElt.attributes[i]!\n      if (!newElt.hasAttribute(name) && !preserveAttrs.includes(name)) {\n        oldElt.removeAttribute(name)\n      }\n    }\n\n    // Preserve the scope marker even if the incoming markup doesn't carry it.\n    if (shouldScopeChildren && !oldElt.hasAttribute('data-scope-children')) {\n      oldElt.setAttribute('data-scope-children', '')\n    }\n\n    if (!oldElt.isEqualNode(newElt)) {\n      morphChildren(oldElt, newElt)\n    }\n\n    if (shouldScopeChildren) {\n      oldElt.dispatchEvent(\n        new CustomEvent('datastar:scope-children', { bubbles: false }),\n      )\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nconst populateIdMapWithTree = (\n  root: Element | ShadowRoot | null,\n  elements: Iterable<Element>,\n): void => {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn\u2019t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport { watcher } from '@engine'\nimport { mergePatch } from '@engine/signals'\nimport { jsStrToObject } from '@utils/text'\n\nwatcher({\n  name: 'datastar-patch-signals',\n  apply({ error }, { signals, onlyIfMissing }) {\n    if (signals) {\n      const ifMissing = onlyIfMissing?.trim() === 'true'\n      mergePatch(jsStrToObject(signals), { ifMissing })\n    } else {\n      throw error('PatchSignalsExpectedSignals')\n    }\n  },\n})\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "hasOwn", "isPojo", "obj", "isEmpty", "prop", "hasOwn", "updateLeaves", "fn", "key", "val", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "acc", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "prevSub", "activeSub", "version", "beginBatch", "endBatch", "flush", "dispatch", "startPeeking", "sub", "stopPeeking", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "effectOper", "run", "update", "updateComputed", "updateSignal", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "propagate", "currentValue", "shallowPropagate", "unlink", "prevDep", "depsTail_", "nextDep", "version_", "subsTail_", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "isValidLink", "subSubs", "nextSub", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "checkLink", "getPath", "path", "result", "root", "split", "hasOwn", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "newValue", "diff", "patch", "i", "pathStr", "nextVal", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "toRegExp", "val", "filtered", "include", "exclude", "obj", "includeRe", "excludeRe", "node", "isHTMLOrSVG", "el", "kebab", "str", "snake", "str", "kebab", "jsStrToObject", "raw", "caseFns", "str", "x", "modifyCasing", "mods", "defaultCase", "c", "aliasify", "name", "url", "error", "ctx", "reason", "metadata", "e", "r", "snake", "q", "c", "actionPlugins", "attributePlugins", "watcherPlugins", "actions", "_", "prop", "removals", "queuedAttributes", "queuedAttributeNames", "observedRoots", "attribute", "plugin", "apply", "action", "DATASTAR_FETCH_EVENT", "evt", "watcher", "cleanupEls", "els", "el", "elCleanups", "attrCleanups", "cleanup", "aliasedIgnore", "aliasify", "aliasedIgnoreAttr", "shouldIgnore", "applyEls", "onlyNew", "key", "applyAttributePlugin", "observe", "mutations", "target", "type", "attributeName", "addedNodes", "removedNodes", "node", "isHTMLOrSVG", "value", "mutationObserver", "parseAttributeKey", "rawKey", "namePart", "rawModifiers", "pluginName", "mods", "rawMod", "label", "mod", "apply", "root", "observeRoot", "isHTMLOrSVG", "applyEls", "mutationObserver", "observedRoots", "applyAttributePlugin", "el", "attrKey", "value", "onlyNew", "rawKey", "pluginName", "key", "mods", "parseAttributeKey", "plugin", "attributePlugins", "queuedAttributeNames", "ctx", "error", "actionPlugins", "keyReq", "valueReq", "keyProvided", "valueProvided", "cleanups", "cachedRx", "args", "genRx", "cleanup", "elCleanups", "removals", "attrCleanups", "oldCleanup", "returnsValue", "argNames", "expr", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "v", "_", "signalName", "acc", "part", "fn", "action", "name", "evt", "err", "actions", "e", "action", "_", "fn", "startPeeking", "stopPeeking", "action", "_", "value", "filter", "startPeeking", "masked", "filtered", "updateLeaves", "mergePatch", "stopPeeking", "action", "_", "filter", "startPeeking", "masked", "filtered", "updateLeaves", "oldValue", "mergePatch", "stopPeeking", "createHttpMethod", "name", "method", "openWhenHiddenDefault", "action", "el", "evt", "error", "cleanups", "url", "selector", "userHeaders", "contentType", "include", "exclude", "openWhenHidden", "payload", "requestCancellation", "retry", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "controller", "cleanupFn", "initialHeaders", "headers", "req", "response", "dispatchFetch", "ERROR", "type", "argsRawLines", "line", "i", "k", "v", "argsRaw", "isWrongContent", "RETRYING", "urlInstance", "queryParams", "startPeeking", "filtered", "stopPeeking", "body", "formEl", "formData", "submitter", "preventDefault", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "e", "FINISHED", "RETRIES_FAILED", "DATASTAR_FETCH_EVENT", "err", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "a", "b", "res", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "responseOverrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "curRequestSignal", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "status", "isNoContentStatus", "isRedirectStatus", "isErrorStatus", "ct", "script", "scriptAttributesHeader", "id", "interval", "innerErr", "attribute", "el", "key", "rx", "syncAttr", "val", "update", "observer", "obj", "attributeFilter", "cleanup", "effect", "dataURIRegex", "empty", "aliasedBind", "aliasify", "attribute", "el", "key", "mods", "value", "error", "signalName", "modifyCasing", "get", "type", "set", "syncSignal", "files", "signalFiles", "f", "resolve", "reader", "match", "mergePaths", "typeMap", "option", "initialValue", "getPath", "path", "signalNameKebab", "inputs", "paths", "i", "input", "signalValue", "cleanup", "effect", "attribute", "key", "el", "mods", "rx", "modifyCasing", "classes", "callback", "observer", "k", "classNames", "cn", "name", "cleanup", "effect", "attribute", "key", "mods", "rx", "error", "mergePaths", "modifyCasing", "computed", "patch", "updateLeaves", "old", "mergePatch", "attribute", "rx", "effect", "attribute", "el", "key", "mods", "value", "signalName", "modifyCasing", "mergePaths", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_FETCH_EVENT", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "throttle", "leading", "trailing", "debounce", "lastArgs", "timer", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "attribute", "rx", "mods", "callback", "beginBatch", "endBatch", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "attribute", "el", "value", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "filtered", "cleanup", "effect", "attribute", "el", "key", "mods", "rx", "target", "callback", "evt", "beginBatch", "endBatch", "modifyViewTransition", "modifyTiming", "evtListOpts", "cb", "eventName", "modifyCasing", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "clamp", "value", "min", "max", "once", "attribute", "el", "mods", "rx", "callback", "beginBatch", "endBatch", "modifyViewTransition", "modifyTiming", "options", "clamp", "exit", "observer", "entries", "entry", "attribute", "mods", "rx", "callback", "beginBatch", "endBatch", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "attribute", "el", "key", "mods", "rx", "error", "filterAttr", "aliasify", "filtersRaw", "filters", "jsStrToObject", "running", "callback", "modifyTiming", "evt", "watched", "filtered", "isEmpty", "beginBatch", "endBatch", "DATASTAR_SIGNAL_PATCH_EVENT", "attribute", "el", "key", "mods", "value", "signalName", "modifyCasing", "mergePaths", "NONE", "DISPLAY", "attribute", "el", "rx", "update", "observer", "cleanup", "effect", "attribute", "key", "mods", "rx", "ifMissing", "modifyCasing", "mergePaths", "patch", "mergePatch", "attribute", "key", "el", "rx", "style", "initialStyles", "apply", "prop", "value", "initial", "update", "observer", "styles", "kebab", "cleanup", "effect", "attribute", "el", "rx", "update", "observer", "cleanup", "effect", "isValidType", "arr", "value", "PATCH_MODES", "NAMESPACES", "watcher", "ctx", "selector", "mode", "namespace", "useViewTransition", "elements", "args2", "supportsViewTransitions", "onPatchElements", "error", "elementsWithSvgsRemoved", "hasHtml", "hasHead", "hasBody", "wrapperTag", "wrappedEls", "newDocument", "newContent", "wrapperEl", "child", "target", "applyToTargets", "targets", "scripts", "script", "execute", "elScripts", "old", "name", "applyPatchMode", "element", "action", "cloned", "morph", "ctxIdMap", "ctxPersistentIds", "oldIdTagNameMap", "duplicateIds", "ctxPantry", "aliasedIgnoreMorph", "aliasify", "aliasedIgnoreMorphAttr", "oldElt", "isHTMLOrSVG", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "parent", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "movedChild", "current", "idSet", "moveBefore", "namespaceURI", "newEmptyChild", "newClonedChild", "node", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "aliasedPreserveAttr", "type", "newElt", "shouldScopeChildren", "preserveAttrs", "i", "root", "elt", "watcher", "error", "signals", "onlyIfMissing", "ifMissing", "mergePatch", "jsStrToObject"]
}
